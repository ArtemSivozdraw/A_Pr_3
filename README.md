Перше завдання

У першому завдані потрідно було реалізувати одну задачу двома засобами. Потрібно було обробити великий двовимірний масив, а саме повернути елементи що дорівнюють сумі своїх індексів. І це треба було зробити за допомогою Work Dealing і Work Stealing.
Work Dealing я реалізував за допомогою ExecutorService, Callable та Future. Основний принцип роботи Work Dealing полягає в тому, щоб рівномірно розподілити роботу між потоками і дати їм працювати. 
Work Stealing має інший принцип роботи. Він полягає в тому щоб потік, якщо він завершив виконання всіх своїх завдань, міг забирати завдання у інших потоків і якшо логічно подумати для цього в пул ForkJoin потрібно кидати більше завдань ніж в ExecuteService. Через це потік перед початком робити дивиться на довжину масиву що має обробити і якщо довжина занадто велика він ділить масив пополам.
Я багато експерементував з умовою поділу масива, спочатку це було просто число. Тобто якщо довжина масиву була більша за 30 (наприклад)  то масив ділився порівну, але через це, при великих вхідних матриць програма видавала StackOverFlow помилку. Це стається через те що стак переповнюється задачами. І через це я прийшов до перевірки яка є зараз в коді. 
Подивившись на виконання Work Dealing і Work Stealing можу сказати, що Work Dealing легше реалізовується і краще підходить для обробки великих кусків інформації. При дуже великих матрицях Work Dealing працює значно швидше ніж Work Stealing, хоча на малих матрицях виграє Work Stealing. Проте Work Stealing є гнучкішим за Work Dealing і дозволяє виконувати такі задачі, які, можна сказати, не під силу Work Dealing. Про це в наступному завдані

Друге завдання

Це завдання, очевидно, я реалізовував за допомогою Work Stealing. І цей метод краще підходить, тому що з самого початку не відомо скільки вкладених папок в даній директорії. І навіть якби було відомо, все одно реалізація за допомогою Work Stealing простіша. Я реалізував так - програма перевіряє всі файли в папці,якщо це фото - воно додається до певного списку, а якщо файл це дерикторія - то створюється нова задача, де будуть перевірятися файли вже дочірньої папки. Цей процес буде виконуватися до ти пір, поки програма не дійде до кінця всіх гілок цього "дерева". І реалізація цього метода дійсно дуже проста

Висновок 

Коротко - Work Dealing краще підходить для обробки стандартних даних, Work Stealing - для нестандартних.